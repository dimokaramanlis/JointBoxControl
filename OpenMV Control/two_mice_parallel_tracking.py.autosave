# Single Color RGB565 Blob Tracking Example
#
# This example shows off single color RGB565 tracking using the OpenMV Cam.

import sensor, image, time, math
from pyb import Pin
from pid import PID

M1Pin_P0 = Pin(Pin.board.P0, Pin.OUT_PP) # P0
print(M1Pin_P0)
M2Pin_P1 = Pin(Pin.board.P1, Pin.OUT_PP) # P1



# Color Tracking Thresholds (L Min, L Max, A Min, A Max, B Min, B Max)
# The below thresholds track in general red/green/blue things. You may wish to tune them...
#thresholds = [(60, 90, 20, 60, 20, 60)]    # Monstre orange
#thresholds = [(0, 15, -20, +20, -20, 20)]   # black mouse
#thresholds = [(15, 40, 0, 30, -65, -20)]   # Blue tape

thresholds = [ (0, 15, -20, +20, -20, 20)]  # black mouse

#thresholds = [(60, 75, -10, +10, 35, 60)]    # Ciseaux

sensor.reset()
sensor.set_pixformat(sensor.RGB565)
sensor.set_framesize(sensor.QVGA)
sensor.skip_frames(time = 2000)
sensor.set_auto_gain(False) # must be turned off for color tracking
sensor.set_auto_whitebal(False) # must be turned off for color tracking

## 90 DEGREES ROTATION -> https://docs.openmv.io/library/omv.sensor.html
#sensor.set_vflip(True)
#sensor.set_hmirror(True)
#sensor.set_transpose(True)

clock = time.clock()

# Only blobs that with more pixels than "pixel_threshold" and more area than "area_threshold" are
# returned by "find_blobs" below. Change "pixels_threshold" and "area_threshold" if you change the
# camera resolution. "merge=True" merges all overlapping blobs in the image.

## References area data (x, y, Valid(founded during scan))
M1_xy = [0,0]
M2_xy = [0,0]

#SequenceLearning Single/TwoMice

#regionX = 23
#regionY = 19


regionX = 20
regionY = 17

#Trained Single/TwoMice

#regionX = 20
#regionY = 17

r_1 = [159-(regionX//2), 110-(regionY//2),regionX, regionY]
r_2 = [183-(regionX//2), 110-(regionY//2),regionX, regionY]

myRegion_M1 = [108, 70, 62, 120]
myRegion_M2 = [170, 70, 62, 120]
while(True):
    clock.tick()
    img = sensor.snapshot()
    blobcount = 0
    for blob in img.find_blobs(thresholds, pixels_threshold=100, area_threshold=100):
        #DRAW THE SEARCH ZONE
        img.draw_rectangle(myRegion_M1, (255, 170, 170), 1, False)
        img.draw_rectangle(myRegion_M2, (170, 170, 255), 1, False)
        img.draw_rectangle(r_1, (255, 0, 0), 1, False)
        img.draw_rectangle(r_2, (0, 0, 255), 1, False)
        if (blob.cx() >= myRegion_M1[0]) and (blob.cx() <= myRegion_M1[0]+ myRegion_M1[2]) and (blob.cy() >= myRegion_M1[1]) and (blob.cy() <= myRegion_M1[1]+ myRegion_M1[3]):
            m_id = 1
            # These values depend on the blob not being circular - otherwise they will be shaky.
            if blob.elongation() > 0.4:
                img.draw_edges(blob.min_corners(), color=(255,0,0))
                img.draw_line(blob.major_axis_line(), color=(0,255,0))
                img.draw_line(blob.minor_axis_line(), color=(0,0,255))
                M1_xy[0] = blob.cx()
                M1_xy[1] = blob.cy()
                print("Mouse ",m_id, " X: ", M1_xy[0], "Y: ", M1_xy[1], " Rotation: ",blob.rotation())
                #If mouse midpoint inside the rectangle
                ###Reminder TO HAVE SYMMETRY OVER PI
                #if M1_xy[0] >= r_1[0] and M1_xy[0] <=  r_1[0]+r_1[2] and M1_xy[1] >= r_1[1] and M1_xy[1] <= r_1[1]+r_1[3] and (blob.rotation()<0.5236 or blob.rotation()> 2.618):
                if M1_xy[0] >= r_1[0] and M1_xy[0] <=  r_1[0]+r_1[2] and M1_xy[1] >= r_1[1] and M1_xy[1] <= r_1[1]+r_1[3] and (blob.rotation()<0.7854 or blob.rotation()> 2.356):
                #if M1_xy[0] >= r_1[0] and M1_xy[0] <=  r_1[0]+r_1[2] and M1_xy[1] >= r_1[1] and M1_xy[1] <= r_1[1]+r_1[3] and (blob.rotation()<1.05 or blob.rotation()> 2.039):
                   M1Pin_P0.value(True)
                   print(M1Pin_P0.value())
                else:
                   M1Pin_P0.value(False)


            # These values are stable all the time.
            img.draw_rectangle(blob.rect())
            img.draw_cross(blob.cx(), blob.cy())
            # Note - the blob rotation is unique to 0-180 only.
            img.draw_keypoints([(blob.cx(), blob.cy(), int(math.degrees(blob.rotation())))], size=20)

            blobcount = blobcount+1
        if (blob.cx() >= myRegion_M2[0]) and (blob.cx() <= myRegion_M2[0]+ myRegion_M2[2]) and (blob.cy() >= myRegion_M2[1]) and (blob.cy() <= myRegion_M2[1]+ myRegion_M2[3]):
            m_id = 2
            # These values depend on the blob not being circular - otherwise they will be shaky.
            if blob.elongation() > 0.4:
                img.draw_edges(blob.min_corners(), color=(255,0,0))
                img.draw_line(blob.major_axis_line(), color=(0,255,0))
                img.draw_line(blob.minor_axis_line(), color=(0,0,255))
                M2_xy[0] = blob.cx()
                M2_xy[1] = blob.cy()
                #print("Mouse ",m_id, " X: ", M2_xy[0], "Y: ", M2_xy[1], " Rotation: ",blob.rotation())
                #If mouse midpoint inside the rectangle
                ###Reminder TO HAVE SYMMETRY OVER PI
                #### <0.5236 > 2.618 / < 0.7854 > 2.356 / < 1.0472 > 2.094
                #if M2_xy[0] >= r_2[0] and M2_xy[0] <=  r_2[0]+r_2[2] and M2_xy[1] >= r_2[1] and M2_xy[1] <= r_2[1]+r_2[3] and  (blob.rotation()<0.5236  or blob.rotation()> 2.618):
                if M2_xy[0] >= r_2[0] and M2_xy[0] <=  r_2[0]+r_2[2] and M2_xy[1] >= r_2[1] and M2_xy[1] <= r_2[1]+r_2[3] and  (blob.rotation()<0.7854  or blob.rotation()> 2.356):
                #if M2_xy[0] >= r_2[0] and M2_xy[0] <=  r_2[0]+r_2[2] and M2_xy[1] >= r_2[1] and M2_xy[1] <= r_2[1]+r_2[3] and  (blob.rotation()<1.05  or blob.rotation()> 2.039):
                   M2Pin_P1.value(True)
                   print(M2Pin_P1.value())
                else:
                   M2Pin_P1.value(False)


            # These values are stable all the time.
            img.draw_rectangle(blob.rect())
            img.draw_cross(blob.cx(), blob.cy())
            # Note - the blob rotation is unique to 0-180 only.
            img.draw_keypoints([(blob.cx(), blob.cy(), int(math.degrees(blob.rotation())))], size=20)

            blobcount = blobcount+1


    ##time.sleep_ms(100)

    #print(clock.fps())
